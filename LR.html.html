<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>左手定则 · 三维交互模型（TTFU:磁场线控件 + 预设修复）</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0a0a0a; color: #e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; }
    #app { display: grid; grid-template-rows: auto 1fr auto; height: 100%; max-width: 1200px; margin: 0 auto; }
    header, footer { padding: 12px 16px; }
    header { position: relative; display:flex; gap: 12px; align-items: baseline; justify-content: space-between; z-index: 5; }
    header h1 { font-size: 18px; margin: 0; color: #fafafa; }
    header p { margin: 0; font-size: 13px; color: #cfcfcf; }
    #scene { position: relative; height: 70vh; border: 1px solid #262626; border-radius: 14px; overflow: hidden; }
    #readout { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 8px; padding: 12px 0 0 0; font-size: 13px; }
    .pill { background:#171717; border:1px solid #262626; border-radius: 10px; padding: 8px 10px; }
    .btns { display:flex; gap:8px; flex-wrap: wrap; }
    .btn { background:#1f1f1f; border:1px solid #2d2d2d; color:#e5e7eb; padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px; }
    .btn:hover { background:#2a2a2a; }
    a { color:#93c5fd; text-decoration: none; }
    .legend { position:absolute; left:10px; top:10px; font-size:12px; color:#e5e7eb; background: rgba(13,13,13,.6); border:1px solid #262626; border-radius:10px; padding:8px 10px; backdrop-filter: blur(3px); }
    .legend b { display:inline-block; width:10px; height:10px; border-radius:2px; margin-right:6px; vertical-align: -1px; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div>
        <h1>左手定则 · 三维交互模型（TTFU）</h1>
        <p>拖动旋转视角；右上角面板调节 <b>B</b> 与 <b>I</b>。掌面法向量固定为 <b>-B^</b>（“B 穿掌心”），四指对准 <i>I⊥</i>，红色箭头为 <b>F ∝ I × B</b>。</p>
      </div>
      <div class="btns" id="preset-bar">
        <button class="btn" id="preset-orth1">I ⟂ B（x ⟂ z）</button>
        <button class="btn" id="preset-orth2">I ⟂ B（x ⟂ y）</button>
        <button class="btn" id="preset-parallel">I ∥ B → F≈0</button>
        <button class="btn" id="preset-reset">复位</button>
      </div>
    </header>

    <div id="scene">
      <div class="legend">
        <div><b style="background:#60a5fa"></b>B 蓝色</div>
        <div><b style="background:#22c55e"></b>I 绿色</div>
        <div><b style="background:#67e8f9"></b>I⊥ 青色（虚线）</div>
        <div><b style="background:#ef4444"></b>F 红色</div>
      </div>
    </div>

    <footer>
      <div id="readout">
        <div class="pill">B·I = <span id="dot">—</span></div>
        <div class="pill">∠(I,B) ≈ <span id="angle">—</span>°</div>
        <div class="pill">|I⊥| ≈ <span id="iperp">—</span>，|F| ∝ |I×B| ≈ <span id="fcross">—</span></div>
      </div>
    </footer>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.1';
    import { OrbitControls } from 'https://esm.sh/three@0.160.1/examples/jsm/controls/OrbitControls.js';
    import GUI from 'https://esm.sh/lil-gui@0.18';

    // ---------- helpers ----------
    const deg2rad = (d) => d * Math.PI / 180;
    const unit = (v) => v.length() > 1e-9 ? v.clone().multiplyScalar(1/v.length()) : new THREE.Vector3(0,0,0);
    const sphToVec = (r, thetaDeg, phiDeg) => {
      const theta = deg2rad(thetaDeg); // 0 = +z
      const phi = deg2rad(phiDeg);     // 0 = +x, CCW around z
      return new THREE.Vector3(
        r * Math.sin(theta) * Math.cos(phi),
        r * Math.sin(theta) * Math.sin(phi),
        r * Math.cos(theta)
      );
    };
    const projectPerp = (v, n) => {
      const nh = unit(n);
      return v.clone().sub(nh.clone().multiplyScalar(v.dot(nh)));
    };

    // ---------- scene ----------
    const sceneEl = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(sceneEl.clientWidth, sceneEl.clientHeight);
    sceneEl.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, sceneEl.clientWidth/sceneEl.clientHeight, 0.01, 100);
    camera.position.set(3.2, 2.4, 3.2);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;

    // grid & axes
    const grid = new THREE.GridHelper(8, 16, 0x333333, 0x222222);
    scene.add(grid);
    const axes = new THREE.AxesHelper(1.5);
    scene.add(axes);

    // palm plane (face the -B direction)
    const palmSize = 1.6;
    const palm = new THREE.Mesh(
      new THREE.PlaneGeometry(palmSize, palmSize),
      new THREE.MeshBasicMaterial({ color: 0xffa500, transparent: true, opacity: 0.18, side: THREE.DoubleSide })
    );
    scene.add(palm);
    palm.position.set(0,0,0);

    // finger decal (shows I⊥ direction on the palm)
    const decalCanvas = document.createElement('canvas');
    decalCanvas.width = 512; decalCanvas.height = 512;
    const decalCtx = decalCanvas.getContext('2d');
    const decalTex = new THREE.CanvasTexture(decalCanvas);
    const decal = new THREE.Mesh(
      new THREE.PlaneGeometry(palmSize, palmSize),
      new THREE.MeshBasicMaterial({ map: decalTex, transparent: true, opacity: 0.9 })
    );
    decal.position.z = 0.011;
    palm.add(decal);

    function drawFingerOnPlane(dirWorld, palmQuat){
      const inv = palmQuat.clone().invert();
      const local = unit(dirWorld.clone().applyQuaternion(inv));
      const w = decalCanvas.width, h = decalCanvas.height;
      decalCtx.clearRect(0,0,w,h);
      // background
      decalCtx.fillStyle = 'rgba(0,0,0,0)';
      decalCtx.fillRect(0,0,w,h);
      // center
      const cx = w/2, cy = h/2;
      // arrow
      const L = 160;
      const x2 = cx + L * local.x;
      const y2 = cy - L * local.y;
      decalCtx.strokeStyle = '#67e8f9';
      decalCtx.lineWidth = 10;
      decalCtx.beginPath();
      decalCtx.moveTo(cx, cy);
      decalCtx.lineTo(x2, y2);
      decalCtx.stroke();
      // head
      const head = 22;
      const ang = Math.atan2(cy - y2, x2 - cx);
      decalCtx.beginPath();
      decalCtx.moveTo(x2, y2);
      decalCtx.lineTo(x2 - head*Math.cos(ang - Math.PI/6), y2 + head*Math.sin(ang - Math.PI/6));
      decalCtx.lineTo(x2 - head*Math.cos(ang + Math.PI/6), y2 + head*Math.sin(ang + Math.PI/6));
      decalCtx.closePath();
      decalCtx.fillStyle = '#67e8f9';
      decalCtx.fill();
      // label
      decalCtx.fillStyle = '#ffffff';
      decalCtx.font = '32px sans-serif';
      decalCtx.fillText('四指 → I⊥', cx + 10, cy - 14);
      decalTex.needsUpdate = true;
    }

    // arrows
    const makeArrow = (color, dashed=false, withLabel='') => {
      const group = new THREE.Group();
      const lineMat = dashed
        ? new THREE.LineDashedMaterial({ color, dashSize: 0.15, gapSize: 0.1 })
        : new THREE.LineBasicMaterial({ color });
      const geom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0,0,0), new THREE.Vector3(1,0,0)
      ]);
      const line = new THREE.Line(geom, lineMat);
      if (dashed) line.computeLineDistances();
      group.add(line);
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.18, 16),
                                  new THREE.MeshBasicMaterial({ color }));
      cone.position.set(1, 0, 0);
      cone.rotation.z = -Math.PI/2;
      group.add(cone);
      if (withLabel) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fs = 56;
        ctx.font = fs+'px sans-serif';
        const w = ctx.measureText(withLabel).width + 20;
        canvas.width = Math.ceil(w);
        canvas.height = fs + 20;
        const ctx2 = canvas.getContext('2d');
        ctx2.font = fs+'px sans-serif';
        ctx2.fillStyle = '#ffffff';
        ctx2.fillText(withLabel, 10, fs);
        const tex = new THREE.CanvasTexture(canvas);
        const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
        spr.scale.set(canvas.width/100, canvas.height/100, 1);
        spr.position.set(1.1, 0, 0);
        group.add(spr);
      }
      scene.add(group);
      return group;
    };

    const arrB = makeArrow('#60a5fa', false, 'B');
    const arrI = makeArrow('#22c55e', false, 'I');
    const arrIP = makeArrow('#67e8f9', true, 'I⊥');
    const arrF = makeArrow('#ef4444', false, 'F');

    const setArrow = (group, from, to) => {
      const dir = to.clone().sub(from);
      const len = dir.length();
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), unit(dir));
      group.position.copy(from);
      group.setRotationFromQuaternion(q);
      // update geometry points
      const pts = [new THREE.Vector3(0,0,0), new THREE.Vector3(len,0,0)];
      const line = group.children[0];
      line.geometry.setFromPoints(pts);
      if (line.computeLineDistances) line.computeLineDistances();
      const cone = group.children[1];
      cone.position.x = len;
    };

    // --- Magnetic field cylinders ---
    const fieldGroup = new THREE.Group();
    scene.add(fieldGroup);
    const fieldParams = {
      show: true,
      density: 6,   // smaller = denser (divider in modulo)
      length: 4.0,
      radius: 0.01,
      opacity: 0.35
    };
    let fieldMat = null;
    let fieldOffsets = [];

    function rebuildFieldOffsets(){
      fieldOffsets = [];
      for (let i = -10; i <= 10; i++) {
        for (let j = -10; j <= 10; j++) {
          // density: pick every Nth by modulo
          if (((i*i + j*j) % fieldParams.density) === 0) {
            fieldOffsets.push(new THREE.Vector3(i*0.15, j*0.15, 0));
          }
        }
      }
    }

    function rebuildFieldLines(){
      // clear previous
      while (fieldGroup.children.length) fieldGroup.remove(fieldGroup.children[0]);
      fieldMat = new THREE.MeshBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: fieldParams.opacity });
      for (const o of fieldOffsets) {
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(fieldParams.radius, fieldParams.radius, fieldParams.length, 12),
                                   fieldMat);
        cyl.position.set(o.x, o.y, -fieldParams.length/2);
        fieldGroup.add(cyl);
      }
      fieldGroup.visible = fieldParams.show;
    }

    rebuildFieldOffsets();
    rebuildFieldLines();

    // readout DOM
    const dotEl = document.getElementById('dot');
    const angleEl = document.getElementById('angle');
    const ipEl = document.getElementById('iperp');
    const fEl = document.getElementById('fcross');

    // parameters (B/I) + GUI
    const params = {
      Bmag: 1.0, Btheta: 60, Bphi: 20,
      Imag: 1.0, Itheta: 120, Iphi: 110
    };
    const gui = new GUI({ title: '参数' });
    const fB = gui.addFolder('磁感线 B');
    fB.add(params, 'Bmag', 0, 2, 0.01).name('幅值（相对）');
    fB.add(params, 'Btheta', 0, 180, 1).name('仰角 θ (0°=+z)');
    fB.add(params, 'Bphi', 0, 360, 1).name('方位角 φ (0°=+x)');
    const fI = gui.addFolder('电流 I');
    fI.add(params, 'Imag', 0, 2, 0.01).name('幅值（相对）');
    fI.add(params, 'Itheta', 0, 180, 1).name('仰角 θ (0°=+z)');
    fI.add(params, 'Iphi', 0, 360, 1).name('方位角 φ (0°=+x)');

    const fM = gui.addFolder('磁场线（蓝色圆柱阵列）');
    fM.add(fieldParams, 'show').name('显示磁场线').onChange(() => { fieldGroup.visible = fieldParams.show; });
    fM.add(fieldParams, 'density', 2, 12, 1).name('密度（越小越密）').onFinishChange(() => { rebuildFieldOffsets(); rebuildFieldLines(); updateVectors(); });
    fM.add(fieldParams, 'length', 1.0, 8.0, 0.1).name('长度').onChange(() => { rebuildFieldLines(); updateVectors(); });
    fM.add(fieldParams, 'radius', 0.005, 0.05, 0.001).name('半径').onChange(() => { rebuildFieldLines(); updateVectors(); });
    fM.add(fieldParams, 'opacity', 0.05, 1.0, 0.01).name('透明度').onChange(() => { if (fieldMat){ fieldMat.opacity = fieldParams.opacity; } });

    fB.open(); fI.open(); fM.open();
    gui.domElement.style.position = 'absolute';
    gui.domElement.style.right = '10px';
    gui.domElement.style.top = '10px';

    // vectors
    let B = new THREE.Vector3(), I = new THREE.Vector3(), Iperp = new THREE.Vector3(), F = new THREE.Vector3();

    function updateVectors(){
      B = sphToVec(params.Bmag, params.Btheta, params.Bphi);
      I = sphToVec(params.Imag, params.Itheta, params.Iphi);
      Iperp = projectPerp(I, B);
      F = I.clone().cross(B);

      // scale for display
      const scale = 1.2;
      const lens = (v) => unit(v).multiplyScalar(scale * (0.6 + 0.4 * Math.tanh(v.length())));

      // palm orientation: normal n = -B^
      const n = unit(B).multiplyScalar(-1);
      const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), unit(n));
      palm.setRotationFromQuaternion(q);

      // finger decal
      drawFingerOnPlane(Iperp, q);

      // B field lines group rotation – align +Z to B^
      const qB = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), unit(B));
      fieldGroup.setRotationFromQuaternion(qB);

      // set arrows
      setArrow(arrB, new THREE.Vector3(0,0,0), lens(B));
      setArrow(arrI, new THREE.Vector3(0,0,0), lens(I));
      if (Iperp.length() > 1e-6) {
        arrIP.visible = true;
        setArrow(arrIP, new THREE.Vector3(0,0,0), lens(Iperp));
      } else {
        arrIP.visible = false;
      }
      setArrow(arrF, new THREE.Vector3(0,0,0), lens(F));

      // readout
      const dot = unit(B).dot(unit(I));
      dotEl.textContent = (params.Bmag*params.Imag*dot).toFixed(3);
      const a = Math.max(-1, Math.min(1, dot));
      angleEl.textContent = (Math.acos(a) * 180/Math.PI).toFixed(1);
      ipEl.textContent = (params.Imag * Math.sqrt(1 - a*a)).toFixed(3);
      fEl.textContent = (params.Bmag * params.Imag * Math.sqrt(1 - a*a)).toFixed(3);
    }

    // initial
    updateVectors();

    // animation loop
    (function loop(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    })();

    // resize
    window.addEventListener('resize', () => {
      renderer.setSize(sceneEl.clientWidth, sceneEl.clientHeight);
      camera.aspect = sceneEl.clientWidth/sceneEl.clientHeight;
      camera.updateProjectionMatrix();
    });

    // ---- PRESETS (robust binding) ----
    function bindPresets(){
      const p1 = document.getElementById('preset-orth1');
      const p2 = document.getElementById('preset-orth2');
      const p3 = document.getElementById('preset-parallel');
      const p4 = document.getElementById('preset-reset');
      if (!p1 || !p2 || !p3 || !p4) return;

      p1.addEventListener('click', () => {
        params.Btheta = 0; params.Bphi = 0; params.Bmag = 1.2;   // B → +z
        params.Itheta = 90; params.Iphi = 0; params.Imag = 1.2;  // I → +x
        gui.updateDisplay(); updateVectors();
      });
      p2.addEventListener('click', () => {
        params.Btheta = 90; params.Bphi = 90; params.Bmag = 1.2; // B → +y
        params.Itheta = 90; params.Iphi = 0;  params.Imag = 1.2; // I → +x → F → +z
        gui.updateDisplay(); updateVectors();
      });
      p3.addEventListener('click', () => {
        params.Btheta = 60; params.Bphi = 20; params.Bmag = 1.2;
        params.Itheta = 60; params.Iphi = 20; params.Imag = 1.2; // I ∥ B → F≈0
        gui.updateDisplay(); updateVectors();
      });
      p4.addEventListener('click', () => {
        params.Btheta = 60; params.Bphi = 20; params.Bmag = 1.0;
        params.Itheta = 120; params.Iphi = 110; params.Imag = 1.0;
        gui.updateDisplay(); updateVectors();
      });
    }

    // Bind once DOM is ready (extra safety for some browsers)
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', bindPresets);
    } else {
      bindPresets();
    }

    // respond to GUI changes
    const onChange = () => updateVectors();
    fB.controllers.forEach(c => c.onChange(onChange));
    fI.controllers.forEach(c => c.onChange(onChange));
  </script>
</body>
</html>
